/**
 * NeuroJSON Protocol Type Definitions
 * 
 * This module defines the serializable JSON format for neurosymbolic logic graphs.
 * All logic can be stored in databases or generated by LLMs using this schema.
 */

// ============================================================================
// Core Types
// ============================================================================

/**
 * A truth value in the range [0, 1] representing degrees of belief.
 * 0 = definitely false, 1 = definitely true, 0.5 = unknown/neutral
 */
export type TruthValue = number;

/**
 * Variable types supported in the logic graph
 */
export type VariableType = 'bool' | 'continuous';

/**
 * Operations that can be performed on inputs
 */
export type Operation = 
  | 'IDENTITY'    // Pass-through: output = input
  | 'AND'         // Conjunction: min(inputs) in Lukasiewicz logic
  | 'OR'          // Disjunction: max(inputs) in Lukasiewicz logic  
  | 'NOT'         // Negation: 1 - input
  | 'WEIGHTED';   // Weighted average of inputs

/**
 * Types of rules in the logic graph
 */
export type RuleType = 
  | 'IMPLICATION'   // A -> B
  | 'EQUIVALENCE'   // A <-> B
  | 'CONJUNCTION'   // A ∧ B
  | 'DISJUNCTION';  // A ∨ B

/**
 * Types of constraints in the logic graph
 */
export type ConstraintType = 
  | 'ATTACK'      // Argumentation: source defeats target
  | 'SUPPORT'     // Argumentation: source supports target
  | 'MUTEX';      // Mutual exclusion: at most one can be true

// ============================================================================
// Schema Components
// ============================================================================

/**
 * A variable (node) in the logic graph
 */
export interface Variable {
  /** Type of the variable */
  type: VariableType;
  /** Prior belief (initial truth value) before evidence */
  prior: TruthValue;
  /** Optional description for explainability */
  description?: string;
  /** If true, this variable's value is locked and won't change during inference */
  locked?: boolean;
}

/**
 * A rule defining logical relationships between variables
 */
export interface Rule {
  /** Unique identifier for this rule */
  id: string;
  /** Type of logical rule */
  type: RuleType;
  /** Input variable names */
  inputs: string[];
  /** Output variable name */
  output: string;
  /** Operation to apply to inputs */
  op: Operation;
  /** Weight/confidence in this rule (0-1) */
  weight: TruthValue;
  /** Whether this rule is learnable (weight can be updated) */
  learnable?: boolean;
  /** Optional description */
  description?: string;
}

/**
 * A constraint (e.g., attack relation in argumentation)
 */
export interface Constraint {
  /** Unique identifier */
  id: string;
  /** Type of constraint */
  type: ConstraintType;
  /** Source variable */
  source: string;
  /** Target variable(s) */
  target: string | string[];
  /** Strength of the constraint */
  weight: TruthValue;
  /** Optional description */
  description?: string;
}

/**
 * Complete NeuroJSON document defining a logic graph
 */
export interface NeuroJSON {
  /** Schema version */
  version: string;
  /** Optional name for this graph */
  name?: string;
  /** Optional description */
  description?: string;
  /** Variables (nodes) in the graph */
  variables: Record<string, Variable>;
  /** Rules defining relationships */
  rules: Rule[];
  /** Constraints (attacks, supports, etc.) */
  constraints: Constraint[];
  /** Optional metadata */
  metadata?: Record<string, unknown>;
}

// ============================================================================
// Runtime State Types
// ============================================================================

/**
 * Runtime state of a variable during inference
 */
export interface VariableState {
  /** Current truth value */
  value: TruthValue;
  /** Lower bound of truth value (for bounds propagation) */
  lower: TruthValue;
  /** Upper bound of truth value */
  upper: TruthValue;
  /** Whether the value is locked (evidence) */
  locked: boolean;
  /** Gradient for backpropagation */
  gradient: number;
}

/**
 * Configuration for the inference engine
 */
export interface InferenceConfig {
  /** Maximum iterations for convergence */
  maxIterations: number;
  /** Convergence threshold (stop when delta < threshold) */
  convergenceThreshold: number;
  /** Learning rate for weight updates */
  learningRate: number;
  /** Damping factor for belief propagation */
  dampingFactor: number;
}

/**
 * Result of an inference pass
 */
export interface InferenceResult {
  /** Final variable states */
  states: Record<string, VariableState>;
  /** Number of iterations to converge */
  iterations: number;
  /** Whether inference converged */
  converged: boolean;
  /** History of changes per iteration (for debugging) */
  history?: Array<Record<string, TruthValue>>;
}

/**
 * Training example for supervised learning
 */
export interface TrainingExample {
  /** Input evidence: variable name -> truth value */
  inputs: Record<string, TruthValue>;
  /** Expected outputs: variable name -> truth value */
  outputs: Record<string, TruthValue>;
}

/**
 * Result of a training session
 */
export interface TrainingResult {
  /** Final loss value */
  loss: number;
  /** Number of epochs completed */
  epochs: number;
  /** Loss history per epoch */
  lossHistory: number[];
  /** Updated weights: rule id -> new weight */
  weights: Record<string, TruthValue>;
}

// ============================================================================
// Validation
// ============================================================================

/**
 * Validation error details
 */
export interface ValidationError {
  path: string;
  message: string;
}

/**
 * Result of schema validation
 */
export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/**
 * Validates a NeuroJSON document
 */
export function validateNeuroJSON(doc: unknown): ValidationResult {
  const errors: ValidationError[] = [];
  
  if (!doc || typeof doc !== 'object') {
    return { valid: false, errors: [{ path: '', message: 'Document must be an object' }] };
  }
  
  const obj = doc as Record<string, unknown>;
  
  // Check version
  if (typeof obj['version'] !== 'string') {
    errors.push({ path: 'version', message: 'Version must be a string' });
  }
  
  // Check variables
  if (!obj['variables'] || typeof obj['variables'] !== 'object') {
    errors.push({ path: 'variables', message: 'Variables must be an object' });
  } else {
    const vars = obj['variables'] as Record<string, unknown>;
    for (const [name, variable] of Object.entries(vars)) {
      if (!variable || typeof variable !== 'object') {
        errors.push({ path: `variables.${name}`, message: 'Variable must be an object' });
        continue;
      }
      const v = variable as Record<string, unknown>;
      if (v['type'] !== 'bool' && v['type'] !== 'continuous') {
        errors.push({ path: `variables.${name}.type`, message: 'Type must be "bool" or "continuous"' });
      }
      if (typeof v['prior'] !== 'number' || v['prior'] < 0 || v['prior'] > 1) {
        errors.push({ path: `variables.${name}.prior`, message: 'Prior must be a number between 0 and 1' });
      }
    }
  }
  
  // Check rules
  if (!Array.isArray(obj['rules'])) {
    errors.push({ path: 'rules', message: 'Rules must be an array' });
  } else {
    const rules = obj['rules'] as unknown[];
    rules.forEach((rule, idx) => {
      if (!rule || typeof rule !== 'object') {
        errors.push({ path: `rules[${idx}]`, message: 'Rule must be an object' });
        return;
      }
      const r = rule as Record<string, unknown>;
      if (typeof r['id'] !== 'string') {
        errors.push({ path: `rules[${idx}].id`, message: 'Rule ID must be a string' });
      }
      if (!['IMPLICATION', 'EQUIVALENCE', 'CONJUNCTION', 'DISJUNCTION'].includes(r['type'] as string)) {
        errors.push({ path: `rules[${idx}].type`, message: 'Invalid rule type' });
      }
      if (!Array.isArray(r['inputs'])) {
        errors.push({ path: `rules[${idx}].inputs`, message: 'Inputs must be an array' });
      }
      if (typeof r['output'] !== 'string') {
        errors.push({ path: `rules[${idx}].output`, message: 'Output must be a string' });
      }
      if (typeof r['weight'] !== 'number' || (r['weight'] as number) < 0 || (r['weight'] as number) > 1) {
        errors.push({ path: `rules[${idx}].weight`, message: 'Weight must be between 0 and 1' });
      }
    });
  }
  
  // Check constraints
  if (!Array.isArray(obj['constraints'])) {
    errors.push({ path: 'constraints', message: 'Constraints must be an array' });
  } else {
    const constraints = obj['constraints'] as unknown[];
    constraints.forEach((constraint, idx) => {
      if (!constraint || typeof constraint !== 'object') {
        errors.push({ path: `constraints[${idx}]`, message: 'Constraint must be an object' });
        return;
      }
      const c = constraint as Record<string, unknown>;
      if (typeof c['id'] !== 'string') {
        errors.push({ path: `constraints[${idx}].id`, message: 'Constraint ID must be a string' });
      }
      if (!['ATTACK', 'SUPPORT', 'MUTEX'].includes(c['type'] as string)) {
        errors.push({ path: `constraints[${idx}].type`, message: 'Invalid constraint type' });
      }
    });
  }
  
  return { valid: errors.length === 0, errors };
}

/**
 * Creates a default variable
 */
export function createVariable(prior: TruthValue = 0.5, type: VariableType = 'bool'): Variable {
  return { type, prior };
}

/**
 * Creates a default inference config
 */
export function createDefaultConfig(): InferenceConfig {
  return {
    maxIterations: 100,
    convergenceThreshold: 0.001,
    learningRate: 0.1,
    dampingFactor: 0.5
  };
}
